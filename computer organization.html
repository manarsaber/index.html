<html>



<head>

<title>computer architecture</title>

</head>



<body dir="ltr" background="https://d3njjcbhbojbot.cloudfront.net/api/utilities/v1/imageproxy/https://coursera-course-photos.s3.amazonaws.com/44/d218105d0111e8ad4d85f20ecaf1cc/comparch-logo.png?auto=format%2Ccompress&dpr=1">

<h1></h1>


<table width ="100%">

  <tr>

    <td> <a href="definition.html"> DEFINITION </a> </td>

    <td> <a href="computer organization.html"> COMPUTER ORGANIZATION </a> </td>
    
    <td> <a href="design goals.html"> DESIGN GOALS </a> </td>
    
    <td> <a href="power efficiency.html"> POWER EFFICIENCY </a> </td>
    

 </tr>

</table>
<br>

<center>  <font color="black" size="12"> Introduction </font>  </center>

Computer organization helps optimize performance-based products. For example, software engineers need to know the processing power of processors. They may need to optimize software in order to gain the most performance for the lowest price. This can require quite a detailed analysis of the computer's organization. For example, in an SD card, the designers might need to arrange the card so that the most data can be processed in the fastest possible way.
Computer organization also helps plan the selection of a processor for a particular project. Multimedia projects may need very rapid data access, while virtual machines may need fast interrupts. Sometimes certain tasks need additional components as well. For example, a computer capable of running a virtual machine needs virtual memory hardware so that the memory of different virtual computers can be kept separated. Computer organization and features also affect power consumption and processor cost.
Implementation
Once an instruction set and micro-architecture have been designed, a practical machine must be developed. This design process is called the implementation. Implementation is usually not considered architectural design, but rather hardware design engineering. Implementation can be further broken down into several steps:
Logic implementation designs the circuits required at a logic-gate level.
Circuit implementation does transistor-level designs of basic elements (e.g., gates, multiplexers, latches) as well as of some larger blocks (ALUs, caches etc.) that may be implemented at the logic-gate level, or even at the physical level if the design calls for it.
Physical implementation draws physical circuits. The different circuit components are placed in a chip floorplan or on a board and the wires connecting them are created.
Design validation tests the computer as a whole to see if it works in all situations and all timings. Once the design validation process starts, the design at the logic level are tested using logic emulators. However, this is usually too slow to run a realistic test. So, after making corrections based on the first test, prototypes are constructed using Field-Programmable Gate-Arrays (FPGAs). Most hobby projects stop at this stage. The final step is to test prototype integrated circuits, which may require several redesigns.
For CPUs, the entire implementation process is organized differently and is often referred to as CPU design.
<br>



</body>



</html>